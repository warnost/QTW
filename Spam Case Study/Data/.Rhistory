headerList = lapply(eSplit, function(msg)
processHeader(msg$header))
# extract content-type key
contentTypes = sapply(headerList, function(header)
header["Content-Type"])
# extract the body
bodyList = lapply(eSplit, function(msg) msg$body)
rm(eSplit)
# which email have attachments
hasAttach = grep("^ *multi", tolower(contentTypes))
# get summary stats for attachments and the shorter body
attList = mapply(processAttach, bodyList[hasAttach],
contentTypes[hasAttach], SIMPLIFY = FALSE)
bodyList[hasAttach] = lapply(attList, function(attEl)
attEl$body)
attachInfo = vector("list", length = n )
attachInfo[ hasAttach ] = lapply(attList,
function(attEl) attEl$attachDF)
# prepare return structure
emailList = mapply(function(header, body, attach, isSpam) {
list(isSpam = isSpam, header = header,
body = body, attach = attach)
},
headerList, bodyList, attachInfo,
rep(isSpam, n), SIMPLIFY = FALSE )
names(emailList) = fileNames
invisible(emailList)
}
# apply the over-arching function to all emails
emailStruct = mapply(processAllEmail, fullDirNames, isSpam = rep( c(FALSE, TRUE), 3:2))
emailStruct = unlist(emailStruct, recursive = FALSE)
# save the processed email file
save(emailStruct, file="emailXX.rda")
# create a derived function that allows the code to remain virtually unchanged when adding/removing functions
createDerivedDF = function(email = emailStruct, operations = funcList, verbose = FALSE) {
els = lapply(names(operations), function(id) {
if(verbose) print(id)
e = operations[[id]]
v = if(is.function(e))
sapply(email, e)
else
sapply(email, function(msg) eval(e))
v
})
df = as.data.frame(els)
names(df) = names(operations)
invisible(df)
}
# create list of functions that can be applied to emails
funcList = list(
isSpam =
expression(msg$isSpam)
,
# is the message a response from an earlier message
isRe =
function(msg) {
# Can have a Fwd: Re:  ... but we are not looking for this here.
# We may want to look at In-Reply-To field.
"Subject" %in% names(msg$header) &&
length(grep("^[ \t]*Re:", msg$header[["Subject"]])) > 0
}
,
numLines =
function(msg) length(msg$body)
,
bodyCharCt =
function(msg)
sum(nchar(msg$body))
,
underscore =
function(msg) {
if(!"Reply-To" %in% names(msg$header))
return(FALSE)
txt <- msg$header[["Reply-To"]]
length(grep("_", txt)) > 0  &&
length(grep("[0-9A-Za-z]+", txt)) > 0
}
,
subExcCt =
function(msg) {
x = msg$header["Subject"]
if(length(x) == 0 || sum(nchar(x)) == 0 || is.na(x))
return(NA)
sum(nchar(gsub("[^!]","", x)))
}
,
subQuesCt =
function(msg) {
x = msg$header["Subject"]
if(length(x) == 0 || sum(nchar(x)) == 0 || is.na(x))
return(NA)
sum(nchar(gsub("[^?]","", x)))
}
,
numAtt =
function(msg) {
if (is.null(msg$attach)) return(0)
else nrow(msg$attach)
}
,
priority =
function(msg) {
ans <- FALSE
# Look for names X-Priority, Priority, X-Msmail-Priority
# Look for high any where in the value
ind = grep("priority", tolower(names(msg$header)))
if (length(ind) > 0)  {
ans <- length(grep("high", tolower(msg$header[ind]))) >0
}
ans
}
,
numRec =
function(msg) {
# unique or not.
els = getMessageRecipients(msg$header)
if(length(els) == 0)
return(NA)
# Split each line by ","  and in each of these elements, look for
# the @ sign. This handles
tmp = sapply(strsplit(els, ","), function(x) grep("@", x))
sum(sapply(tmp, length))
}
,
perCaps =
function(msg)
{
body = paste(msg$body, collapse = "")
# Return NA if the body of the message is "empty"
if(length(body) == 0 || nchar(body) == 0) return(NA)
# Eliminate non-alpha characters and empty lines
body = gsub("[^[:alpha:]]", "", body)
els = unlist(strsplit(body, ""))
ctCap = sum(els %in% LETTERS)
100 * ctCap / length(els)
}
,
isInReplyTo =
function(msg)
{
"In-Reply-To" %in% names(msg$header)
}
,
sortedRec =
function(msg)
{
ids = getMessageRecipients(msg$header)
all(sort(ids) == ids)
}
,
subPunc =
function(msg)
{
if("Subject" %in% names(msg$header)) {
el = gsub("['/.:@-]", "", msg$header["Subject"])
length(grep("[A-Za-z][[:punct:]]+[A-Za-z]", el)) > 0
}
else
FALSE
},
hour =
function(msg)
{
date = msg$header["Date"]
if ( is.null(date) ) return(NA)
# Need to handle that there may be only one digit in the hour
locate = regexpr("[0-2]?[0-9]:[0-5][0-9]:[0-5][0-9]", date)
if (locate < 0)
locate = regexpr("[0-2]?[0-9]:[0-5][0-9]", date)
if (locate < 0) return(NA)
hour = substring(date, locate, locate+1)
hour = as.numeric(gsub(":", "", hour))
locate = regexpr("PM", date)
if (locate > 0) hour = hour + 12
locate = regexpr("[+-][0-2][0-9]00", date)
if (locate < 0) offset = 0
else offset = as.numeric(substring(date, locate, locate + 2))
(hour - offset) %% 24
}
,
multipartText =
function(msg)
{
if (is.null(msg$attach)) return(FALSE)
numAtt = nrow(msg$attach)
types =
length(grep("(html|plain|text)", msg$attach$aType)) > (numAtt/2)
}
,
hasImages =
function(msg)
{
if (is.null(msg$attach)) return(FALSE)
length(grep("^ *image", tolower(msg$attach$aType))) > 0
}
,
isPGPsigned =
function(msg)
{
if (is.null(msg$attach)) return(FALSE)
length(grep("pgp", tolower(msg$attach$aType))) > 0
},
perHTML =
function(msg)
{
if(! ("Content-Type" %in% names(msg$header))) return(0)
el = tolower(msg$header["Content-Type"])
if (length(grep("html", el)) == 0) return(0)
els = gsub("[[:space:]]", "", msg$body)
totchar = sum(nchar(els))
totplain = sum(nchar(gsub("<[^<]+>", "", els )))
100 * (totchar - totplain)/totchar
},
subSpamWords =
function(msg)
{
if("Subject" %in% names(msg$header))
length(grep(paste(SpamCheckWords, collapse = "|"),
tolower(msg$header["Subject"]))) > 0
else
NA
}
,
subBlanks =
function(msg)
{
if("Subject" %in% names(msg$header)) {
x = msg$header["Subject"]
# should we count blank subject line as 0 or 1 or NA?
if (nchar(x) == 1) return(0)
else 100 *(1 - (nchar(gsub("[[:blank:]]", "", x))/nchar(x)))
} else NA
}
,
noHost =
function(msg)
{
# Or use partial matching.
idx = pmatch("Message-", names(msg$header))
if(is.na(idx)) return(NA)
tmp = msg$header[idx]
return(length(grep(".*@[^[:space:]]+", tmp)) ==  0)
}
,
numEnd =
function(msg)
{
# If we just do a grep("[0-9]@",  )
# we get matches on messages that have a From something like
# " \"marty66@aol.com\" <synjan@ecis.com>"
# and the marty66 is the "user's name" not the login
# So we can be more precise if we want.
x = names(msg$header)
if ( !( "From" %in% x) ) return(NA)
login = gsub("^.*<", "", msg$header["From"])
if ( is.null(login) )
login = gsub("^.*<", "", msg$header["X-From"])
if ( is.null(login) ) return(NA)
login = strsplit(login, "@")[[1]][1]
length(grep("[0-9]+$", login)) > 0
},
# identifies if all alpha characters in the subject line are upper case
isYelling =
function(msg)
{
if ( "Subject" %in% names(msg$header) ) {
el = gsub("[^[:alpha:]]", "", msg$header["Subject"])
if (nchar(el) > 0) nchar(gsub("[A-Z]", "", el)) < 1
else FALSE
}
else
NA
},
forwards =
function(msg)
{
x = msg$body
if(length(x) == 0 || sum(nchar(x)) == 0)
return(NA)
ans = length(grep("^[[:space:]]*>", x))
100 * ans / length(x)
},
isOrigMsg =
function(msg)
{
x = msg$body
if(length(x) == 0) return(NA)
length(grep("^[^[:alpha:]]*original[^[:alpha:]]+message[^[:alpha:]]*$",
tolower(x) ) ) > 0
},
isDear =
function(msg)
{
x = msg$body
if(length(x) == 0) return(NA)
length(grep("^[[:blank:]]*dear +(sir|madam)\\>",
tolower(x))) > 0
},
isWrote =
function(msg)
{
x = msg$body
if(length(x) == 0) return(NA)
length(grep("(wrote|schrieb|ecrit|escribe):", tolower(x) )) > 0
},
avgWordLen =
function(msg)
{
txt = paste(msg$body, collapse = " ")
if(length(txt) == 0 || sum(nchar(txt)) == 0) return(0)
txt = gsub("[^[:alpha:]]", " ", txt)
words = unlist(strsplit(txt, "[[:blank:]]+"))
wordLens = nchar(words)
mean(wordLens[ wordLens > 0 ])
}
,
numDlr =
function(msg)
{
x = paste(msg$body, collapse = "")
if(length(x) == 0 || sum(nchar(x)) == 0)
return(NA)
nchar(gsub("[^$]","", x))
}
)
# spam words
SpamCheckWords = c("viagra", "pounds", "free", "weight", "guarantee", "million", "dollars", "credit", "risk", "prescription", "generic", "drug",
"financial", "save", "dollar", "erotic", "million", "barrister", "beneficiary", "easy", "money back", "money", "credit card")
getMessageRecipients = function(header) {
c(if("To" %in% names(header))  header[["To"]] else character(0),
if("Cc" %in% names(header))  header[["Cc"]] else character(0),
if("Bcc" %in% names(header)) header[["Bcc"]] else character(0)
)
}
# add in additional derived variables
emailDF = createDerivedDF(emailStruct)
### exploring email feature set ###
# boxplot for percent of body that is capitalized
# shows that about 75% of the not spam emails have values below the lower quartile for spam
# this variable may be useful for classification
percent = emailDF$perCaps
isSpamLabs = factor(emailDF$isSpam, labels = c("not spam", "spam"))
#boxplot(log(1 + percent) ~ isSpamLabs, ylab = "Percent Capitals (log)")
# QQ plot for percent of body that is capitalized
# spam/not spam distributions have roughly the same shape
# spam messages have a larger average number of capital letters and a greater spread than non-spam messages
logPerCapsSpam = log(1 + emailDF$perCaps[ emailDF$isSpam ])
logPerCapsHam = log(1 + emailDF$perCaps[ !emailDF$isSpam ])
#qqplot(logPerCapsSpam, logPerCapsHam, xlab = "Regular Email", ylab = "Spam Email", main = "Percentage of Capital Letters (log scale)", pch = 19, cex = 0.3)
# compare the joint distribution of the percentage of capital letters in the email and the total number of characters in the body
# spam is purple, not spam is green
# spam tends to be longer and have more capitalization that not spam
colI = c("#4DAF4A80", "#984EA380")
logBodyCharCt = log(1 + emailDF$bodyCharCt)
logPerCaps = log(1 + emailDF$perCaps)
#plot(logPerCaps ~ logBodyCharCt, xlab = "Total Characters (log)",ylab = "Percent Capitals (log)", col = colI[1 + emailDF$isSpam],xlim = c(2,12), pch = 19, cex = 0.5)
# there is little difference between spam/not spam when looking at the counts of email attachments (most emails have no attachments)
table(emailDF$numAtt, isSpamLabs)
# look at whether there is RE: and if there is a # at the end of the sender's email address
# spam messages are less likely to contain RE: but more likely to have a number at the end of the sender's email address
#oldPar = par(mfrow = c(1, 2), mar = c(1,1,1,1))
#colM = c("#E41A1C80", "#377EB880")
#isRe = factor(emailDF$isRe, labels = c("no Re:", "Re:"))
#mosaicplot(table(isSpamLabs, isRe), main = "",xlab = "", ylab = "", color = colM)
#fromNE = factor(emailDF$numEnd, labels = c("No #", "#"))
#mosaicplot(table(isSpamLabs, fromNE), color = colM, main = "", xlab="", ylab = "")
#par(oldPar)
### recursive partitioning ###
library(rpart)
# variables must all be either factors or numeric
# need to convert logicals to factors
setupRpart = function(data) {
logicalVars = which(sapply(data, is.logical))
facVars = lapply(data[ , logicalVars], function(x) {
x = as.factor(x)
levels(x) = c("F", "T")
x
})
cbind(facVars, data[ , - logicalVars])
}
emailDFrp = setupRpart(emailDF)
# training/test split 70%/30%
set.seed(418910)
testSpamIdx = sample(numSpam, size = floor(numSpam/3))
testHamIdx = sample(numHam, size = floor(numHam/3))
testDF = rbind( emailDFrp[ emailDFrp$isSpam == "T", ][testSpamIdx, ], emailDFrp[emailDFrp$isSpam == "F", ][testHamIdx, ] )
trainDF = rbind( emailDFrp[emailDFrp$isSpam == "T", ][-testSpamIdx, ], emailDFrp[emailDFrp$isSpam == "F", ][-testHamIdx, ])
# fit the classification tree
rpartFit = rpart(isSpam ~ ., data = trainDF, method = "class")
# plot tree
library(rpart.plot)
prp(rpartFit, extra = 1)
# predict on the test df
predictions = predict(rpartFit, newdata = testDF[, names(testDF) != "isSpam"], type = "class")
# type I error where not spam is missclassified as spam, 0.65
predsForHam = predictions[ testDF$isSpam == "F" ]
summary(predsForHam)
sum(predsForHam == "T") / length(predsForHam)
# type II error, 0.19
predsForSpam = predictions[ testDF$isSpam == "T" ]
sum(predsForSpam == "F") / length(predsForSpam)
# let's explore the complexity parameter
# used as a threshold where any split that does not decrease the overall lack of fit by cp is not considered
complexityVals = c(seq(0.00001, 0.0001, length=19), seq(0.0001, 0.001, length=19), seq(0.001, 0.005, length=9), seq(0.005, 0.01, length=9))
# call rpart() with each of these values for cp
# train and predict
fits = lapply(complexityVals, function(x) {
rpartObj = rpart(isSpam ~ ., data = trainDF, method="class", control = rpart.control(cp=x) )
predict(rpartObj, newdata = testDF[ , names(testDF) != "isSpam"], type = "class")
})
# calculate type I and II errors
spam = testDF$isSpam == "T"
numSpam = sum(spam)
numHam = sum(!spam)
errs = sapply(fits, function(preds) {
typeI = sum(preds[ !spam ] == "T") / numHam
typeII = sum(preds[ spam ] == "F") / numSpam
c(typeI = typeI, typeII = typeII)
})
# plot errors
library(RColorBrewer)
cols = brewer.pal(9, "Set1")[c(3, 4, 5)]
plot(errs[1,] ~ complexityVals, type="l", col=cols[2], lwd = 2, ylim = c(0,0.2), xlim = c(0,0.01), ylab="Error", xlab="complexity parameter values")
points(errs[2,] ~ complexityVals, type="l", col=cols[1], lwd = 2)
text(x =c(0.003, 0.0035), y = c(0.12, 0.05), labels=c("Type II Error", "Type I Error"))
minI = which(errs[1,] == min(errs[1,]))[1]
abline(v = complexityVals[minI], col ="grey", lty =3, lwd=2)
text(0.0007, errs[1, minI]+0.01, formatC(errs[1, minI], digits = 2))
text(0.0007, errs[2, minI]+0.01, formatC(errs[2, minI], digits = 3))
save(emailDFrp,file="data.Rda")
################
# pick up here #
################
library(caret)
# Ok so first of all our data is in T/F 'factors'.
# We need to change it to numbers.  And as it turns out, there are quite a few NANs as well.  Let's set those to zero.
setupRnum = function(data) {
logicalVars = which(sapply(data, is.logical))
facVars = lapply(data[ , logicalVars], function(x) {
x = as.numeric(x)
})
cbind(facVars, data[ , - logicalVars])
}
emailDFnum = setupRnum(emailDF)
emailDFnum[is.na(emailDFnum)]<-0
# Because our authors prefer Type I/II errors, but the cool kids know that precision/recall/F1 is where its at, while the default of caret is accuracy and kappa.
# To get us all on the same page, I create a function that returns the metrics we want.
# However, rather than re-invent the wheel, I just install a package.  I am not sure if it had Type I/II errors so those I made my self.
library(MLmetrics)
f1 <- function(data, lev = NULL, model = NULL) {
f1_val <- F1_Score(y_pred = data$pred, y_true = data$obs, positive = lev[1])
p <- Precision(y_pred = data$pred, y_true = data$obs, positive = lev[1])
r <- Recall(y_pred = data$pred, y_true = data$obs, positive = lev[1])
fp <-sum(data$pred==0 & data$obs==1)/length(data$pred)
fn <-sum(data$pred==1 & data$obs==0)/length(data$pred)
c(F1 = f1_val,
prec = p,
rec = r,
Type_I_err=fp,
Type_II_err=fn)
}
library(naivebayes)
library(e1071)
# make a dataframe of all the parameters to check
# https://topepo.github.io/caret/available-models.html
nb_grid<-expand.grid(laplace=c(0,0.1,0.3,0.5,1), usekernel=c(T,F), adjust=c(T,F))
# Then we create a trainControl object.  It tells caret how to train--using a cross-validation ('cv') with 3 folds in this case (number = 3).
# We want the final predictions of the best model and our summary is the custom function from above.
train_control<-trainControl(method="cv", number=3, savePredictions = 'final',summaryFunction = f1)
# Then we create our model: "model_nb".  We use the caret::train method.  We make 'isSpam' a factor because R is dumb and can't figure out that 1 and 0 are classes.
model_nb<-caret::train(as.factor(isSpam) ~ .,data=emailDFnum, trControl = train_control, method='naive_bayes',tuneGrid = nb_grid, na.action = na.omit)
model_nb
#Did the boss fool us with the folds?  Nope.
table(model_nb$pred['Resample'])
val<-seq(from = 0, to=0.01, by=0.0005)
library(rpart)
cart_grid<-expand.grid(cp=val)
train_control<-trainControl(method="cv", number =5, savePredictions = 'final',summaryFunction = f1)
model_rpart<-caret::train(as.factor(isSpam) ~ .,data=emailDFnum, trControl = train_control, method='rpart',tuneGrid = cart_grid, na.action = na.omit)
model_rpart
library(randomForest)
rf_grid<-expand.grid(mtry=seq(from =1, to = 25, by = 2))
train_control<-trainControl(method="cv", number=3, savePredictions = 'final',summaryFunction = f1)
model_rf<-caret::train(as.factor(isSpam) ~ .,data=emailDFnum, trControl = train_control, ntree=200,method='rf',tuneGrid = rf_grid, na.action = na.omit)
model_rf
library(xgboost)
xgb_grid<-expand.grid(nrounds = 100, max_depth = c(3,5,7,9,11), eta = c(0.01,0.03,0.1), gamma=c(1,3,5,10), colsample_bytree=1, min_child_weight=1, subsample=1)
train_control<-trainControl(method="cv", number=3, savePredictions = 'final',summaryFunction = f1)
model_xgb<-caret::train(as.factor(isSpam) ~ .,data=emailDFnum, trControl = train_control,method='xgbTree',tuneGrid = xgb_grid, na.action = na.omit)
model_xgb
?rpart.control
train_control<-rpart.control(minsplit = 1)
model_rpart<-caret::train(as.factor(isSpam) ~ .,data=emailDFnum, trControl = train_control, method='rpart',tuneGrid = cart_grid, na.action = na.omit)
?expand.grid
modelLookup("rpart2")
modelLookup("rpart")
?train
?trainControl
modelInfo("xgbTree")
modelLookup("xgbTree")
?rpart.control
val<-seq(from = 0, to=0.01, by=0.0005)
library(rpart)
cart_grid<-expand.grid(cp=val)
train_control<-trainControl(method="cv", number =5, savePredictions = 'final',summaryFunction = f1)
# train_control<-rpart.control(minsplit = 1)
model_rpart<-caret::train(as.factor(isSpam) ~ .,data=emailDFnum, trControl = train_control, method='rpart',tuneGrid = cart_grid, na.action = na.omit)
model_rpart$results
results=as.data.frame(model_rpart$results)
str(restuls)
str(results)
results[which(results$cp==min(results$cp)),]
